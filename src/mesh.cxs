Strict

Private
Import bone
Import brl.datastream
Import brl.filepath
Import brl.databuffer
Import cache
Import color
Import material
Import math3d
Import mojo.app
Import renderer
Import surface
Import texture
Import loader_b3d

Public

    '---------------------------------------------------------------------------------------
Class TraceInfo
    Public
        Field mSurface:Surface
        Field mTriangle:Int
        Field mDistance:Float
        Field mPoint:Float[3]
        Field mNormal:Float[3]
End
    '---------------------------------------------------------------------------------------

Class Mesh

    '---------------------------------------------------------------------------------------
Private

	Field rtVertexPosition0:Float[3]
	Field rtVertexPosition1:Float[3]
	Field rtVertexPosition2:Float[3]
	Field rtTriangleEdge1:Float[3]
	Field rtTriangleEdge2:Float[3]
	Field rtTriangleCross:Float[3]
	Field rtIntersectionInfo:Float[3]
	
	Method rtGetTriangleData:Void( meshSurface:Surface, triangleIndex:Int )
	    Local vertexIndex0:Int = meshSurface.TriangleV0( triangleIndex )
	    Local vertexIndex1:Int = meshSurface.TriangleV1( triangleIndex )
	    Local vertexIndex2:Int = meshSurface.TriangleV2( triangleIndex )
	    rtVertexPosition0[0] = meshSurface.VertexX( vertexIndex0 )
	    rtVertexPosition0[1] = meshSurface.VertexY( vertexIndex0 )
	    rtVertexPosition0[2] = meshSurface.VertexZ( vertexIndex0 )
	    rtVertexPosition1[0] = meshSurface.VertexX( vertexIndex1 )
	    rtVertexPosition1[1] = meshSurface.VertexY( vertexIndex1 )
	    rtVertexPosition1[2] = meshSurface.VertexZ( vertexIndex1 )
	    rtVertexPosition2[0] = meshSurface.VertexX( vertexIndex2 )
	    rtVertexPosition2[1] = meshSurface.VertexY( vertexIndex2 )
	    rtVertexPosition2[2] = meshSurface.VertexZ( vertexIndex2 )
	    Vec3Sub( rtTriangleEdge1, rtVertexPosition1, rtVertexPosition0 )
	    Vec3Sub( rtTriangleEdge2, rtVertexPosition2, rtVertexPosition0 )
	    Vec3Cross( rtTriangleCross, rtTriangleEdge1, rtTriangleEdge2 )
	End

Public

	Method RayTrace:Bool( traceInfo:TraceInfo, rayOrigin:Float[], rayDirection:Float[] )
	    Local nearestSurface:Surface = Null
	    Local nearestTriangle:Int = -1
	    Local minDistance:Float = 10000000000.0
	    For Local surfaceIndex:Int = 0 Until NumSurfaces
	        Local meshSurface:Surface = Self.Surface( surfaceIndex )
	        For Local triangleIndex:Int = 0 Until meshSurface.NumTriangles
	            rtGetTriangleData( meshSurface, triangleIndex )
	            If Vec3Dot( rayDirection, rtTriangleCross ) >= 0.0 Then Continue
	            If Not RayTriangleIntersection( rtIntersectionInfo, rayOrigin, rayDirection, rtVertexPosition0, rtVertexPosition1, rtVertexPosition2 ) Then Continue
	            If rtIntersectionInfo[0] >= minDistance Then Continue
	            minDistance = rtIntersectionInfo[0]
	            nearestTriangle = triangleIndex
	            nearestSurface = meshSurface
	        End
	    End
	    If nearestSurface = Null Then Return False
	    traceInfo.mSurface  = nearestSurface
	    traceInfo.mTriangle = nearestTriangle
	    traceInfo.mDistance = minDistance
	    traceInfo.mPoint[0] = rayOrigin[0] + rayDirection[0] * minDistance
	    traceInfo.mPoint[1] = rayOrigin[1] + rayDirection[1] * minDistance
	    traceInfo.mPoint[2] = rayOrigin[2] + rayDirection[2] * minDistance
	    rtGetTriangleData( nearestSurface, nearestTriangle )
	    Vec3Normalize( traceInfo.mNormal, rtTriangleCross )
	    Return True
	End
    '--------------------------------------------------------

	Method New()
		mFilename = ""
		mSurfaces = New Surface[0]
		mMaterials = New Material[0]
		mBones = New Bone[0]
		mSequences = New AnimSequence[0]
		'mNumFrames = 0
		'mAnimSpeed = 0
	End
	
	Method New(other:Mesh)
		mFilename = other.mFilename
		mSurfaces = New Surface[other.mSurfaces.Length]
		For Local i:Int = 0 Until other.mSurfaces.Length
			mSurfaces[i] = New Surface(other.mSurfaces[i])
		Next
		mMaterials = New Material[other.mMaterials.Length]
		For Local i:Int = 0 Until other.mMaterials.Length
			mMaterials[i] = New Material(other.mMaterials[i])
		Next
		mBones = New Bone[other.mBones.Length]
		For Local i:Int = 0 Until other.mBones.Length
			mBones[i] = New Bone(other.mBones[i])
		Next
		mSequences = New AnimSequence[other.mSequences.Length]
		For Local i:Int = 0 Until other.mSequences.Length
			mSequences[i] = New AnimSequence(other.mSequences[i].mName, other.mSequences[i].mFps, other.mSequences[i].mFirstFrame, other.mSequences[i].mLastFrame)
		Next
		'mNumFrames = other.mNumFrames
		'mAnimSpeed = other.mAnimSpeed
		Vec3Set(other.mBoxMin[0], other.mBoxMin[1], other.mBoxMin[2], mBoxMin)
		Vec3Set(other.mBoxMax[0], other.mBoxMax[1], other.mBoxMax[2], mBoxMax)
	End
	
	#Rem
	Function Load:Mesh(filename:String, skeletonFilename:String = "", texFilter:Int = Renderer.FilterTrilinear, cache:Bool = True)
		Local mesh:Mesh
		If cache
			mesh = Cache._LoadMesh(filename, skeletonFilename, texFilter)
		Else
			'Fix filename
			Local fixedFilename:String = filename
			If filename.Length > 2 And String.FromChar(filename[0]) <> "/" And String.FromChar(filename[1]) <> ":" Then fixedFilename = "cerberus://data/" + filename

			mesh = _LoadData(DataBuffer.Load(fixedFilename), filename, texFilter)
		End
		
		If mesh And skeletonFilename <> "" Then mesh.LoadSkeleton(skeletonFilename)
		
		Return mesh
	End
	#End
	
	Function Load:Mesh(filename:String, texFilter:Int = Renderer.FilterTrilinear, cache:Bool = True)
		Local mesh:Mesh
		If cache
			mesh = Cache._LoadMesh(filename, texFilter)
		Else
			'Fix filename
			Local fixedFilename:String = filename
			If filename.Length > 2 And String.FromChar(filename[0]) <> "/" And String.FromChar(filename[1]) <> ":" Then fixedFilename = "cerberus://data/" + filename
			
			Local fileExt := ExtractExt(fixedFilename).ToLower()
			Select fileExt
				Case "obj"
					mesh = _LoadData_OBJ(filename, texFilter)
				Case "b3d"
					Local loader := New LoaderB3D
					mesh = loader.LoadData(fixedFilename, filename)
				Default
'Print ("fixedFilename="+fixedFilename)
					mesh = _LoadData(DataBuffer.Load(fixedFilename), filename, texFilter)
			End
		End
		Return mesh
	End
	
	Function IsLoaded:Bool(filename:String)
		Return Cache._LoadedMesh(filename) <> Null
	End
	
	#Rem
	Method LoadSkeleton:Bool(filename:String)
		'Fix filename
		Local fixedFilename:String = filename
		If filename.Length > 2 And String.FromChar(filename[0]) <> "/" And String.FromChar(filename[1]) <> ":" Then fixedFilename = "cerberus://data/" + filename
		
		Return _LoadSkeletonData(DataBuffer.Load(fixedFilename))
	End
	
	Method LoadAnimation:Bool(filename:String, sequenceName:String = "")
		'Fix filename
		Local fixedFilename:String = filename
		If filename.Length > 2 And String.FromChar(filename[0]) <> "/" And String.FromChar(filename[1]) <> ":" Then fixedFilename = "cerberus://data/" + filename
		
		Return _LoadAnimationData(DataBuffer.Load(fixedFilename), sequenceName)
	End
	#End
	
	Method LoadVertexAnimation:Bool(filename:String, sequenceName:String = "")
		'Fix filename
		Local fixedFilename:String = filename
		If filename.Length > 2 And String.FromChar(filename[0]) <> "/" And String.FromChar(filename[1]) <> ":" Then fixedFilename = "cerberus://data/" + filename
		
		Return _LoadVertexAnimationData(DataBuffer.Load(fixedFilename), sequenceName)
	End

	Method Discard:Void(discardTextures:Bool = False)
		For Local surf:Surface = Eachin mSurfaces
			surf.Discard()
		Next
		If discardTextures
			For Local mat:Material = Eachin mMaterials
				mat.DiscardTextures()
			Next
		End
	End
	
	Method Filename:Void(filename:String) Property
		mFilename = filename
	End

	Method Filename:String() Property
		Return mFilename
	End

	Method AddSurface:Void(surf:Surface, mat:Material = Null)
		If mat = Null Then mat = New Material
		mSurfaces = mSurfaces.Resize(mSurfaces.Length + 1)
		mSurfaces[mSurfaces.Length-1] = surf
		Rebuild()
		surf.Rebuild()
		mMaterials = mMaterials.Resize(mMaterials.Length + 1)
		mMaterials[mMaterials.Length-1] = mat
	End

	Method NumSurfaces:Int() Property
		Return mSurfaces.Length
	End

	Method Surface:Surface(index:Int)
		Return mSurfaces[index]
	End
	
	Method Material:Material(index:Int)
		Return mMaterials[index]
	End
	
	Method NumFrames:Int() Property
		If mSequences.Length = 0
			Return 0
		Else
			Return mSequences[mSequences.Length-1].mLastFrame
		End
		'Return mNumFrames
	End

	#Rem
	Method NumFrames:Void(num:Int) Property
		mNumFrames = num
	End
	#End
	
	#Rem
	Method AnimFps:Float() Property
		Return mAnimSpeed
	End

	Method AnimFps:Void(fps:Float) Property
		mAnimSpeed = fps
	End
	#End
	
	#Rem
	Method AnimDuration:Float() Property
		If mAnimSpeed = 0
			Return 0
		Else
			Return mNumFrames / mAnimSpeed
		End
	End
	#End
	
	#Rem
	Method AddBone:Void(bone:Bone)
		mBones = mBones.Resize(mBones.Length() + 1)
		mBones[mBones.Length() - 1] = bone
	End
	
	Method NumBones:Int() Property
		Return mBones.Length()
	End
	
	Method Bone:Bone(index:Int)
		If index = -1 Then Return Null
		Return mBones[index]
	End
	
	Method BoneIndex:Int(name:String)
		For Local i:Int = 0 Until mBones.Length()
			If mBones[i].Name = name Then Return i
		Next
		Return -1
	End
	#End
	
	Method Width:Float() Property
		Return mBoxMax[0] - mBoxMin[0]
	End
	
	Method Height:Float() Property
		Return mBoxMax[1] - mBoxMin[1]
	End
	
	Method Depth:Float() Property
		Return mBoxMax[2] - mBoxMin[2]
	End
	
	Method Rebuild:Void()
		If NumSurfaces > 0 And Surface(0).NumVertices > 0
			'Init
			Vec3Set(Surface(0).VertexX(0), Surface(0).VertexY(0), Surface(0).VertexZ(0), mBoxMin)
			Vec3Set(mBoxMin[0], mBoxMin[1], mBoxMin[2], mBoxMax)
		Else
			Vec3Set(0, 0, 0, mBoxMin)
			Vec3Set(0, 0, 0, mBoxMax)
		End
			
		'Iterate through each geom
		For Local surf:Surface = Eachin mSurfaces
			For Local index:Int = 1 Until surf.NumVertices
				Local vx:Float = surf.VertexX(index)
				Local vy:Float = surf.VertexY(index)
				Local vz:Float = surf.VertexZ(index)
				If vx < mBoxMin[0] Then mBoxMin[0] = vx
				If vy < mBoxMin[1] Then mBoxMin[1] = vy
				If vz < mBoxMin[2] Then mBoxMin[2] = vz
				If vx > mBoxMax[0] Then mBoxMax[0] = vx
				If vy > mBoxMax[1] Then mBoxMax[1] = vy
				If vz > mBoxMax[2] Then mBoxMax[2] = vz
			Next
			surf.Rebuild()
		Next
	End
	
	Method BoxMinX:Float() Property
		Return mBoxMin[0]
	End
	
	Method BoxMinY:Float() Property
		Return mBoxMin[1]
	End
	
	Method BoxMinZ:Float() Property
		Return mBoxMin[2]
	End
	
	Method BoxMaxX:Float() Property
		Return mBoxMax[0]
	End
	
	Method BoxMaxY:Float() Property
		Return mBoxMax[1]
	End
	
	Method BoxMaxZ:Float() Property
		Return mBoxMax[2]
	End
	
	Method Translate:Void(x:Float, y:Float, z:Float)
		For Local surf:Surface = Eachin mSurfaces
			surf.Translate(x, y, z)
		Next
		Rebuild()
	End

	Method Rotate:Void(pitch:Float, yaw:Float, roll:Float)
		For Local surf:Surface = Eachin mSurfaces
			surf.Rotate(pitch, yaw, roll)
		Next
		Rebuild()
	End

	Method Scale:Void(x:Float, y:Float, z:Float)
		For Local surf:Surface = Eachin mSurfaces
			surf.Scale(x, y, z)
		Next
		Rebuild()
	End

	Method Flip:Void()
		For Local surf:Surface = Eachin mSurfaces
			surf.Flip()
		Next
	End

	Method ColorVertices:Void(color:Int)
		For Local surf:Surface = Eachin mSurfaces
			surf.ColorVertices(color)
		Next
	End
	
	Function CreateTriangle:Mesh()
		Local surf:Surface = New Surface
		surf.AddVertex(   0,  0.5, 0,  0, 0, -1,  Color.White,  0, 0)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddVertex( 0.5, -0.5, 0,  0, 0, -1,  Color.White,  1, 1)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddVertex(-0.5, -0.5, 0,  0, 0, -1,  Color.White,  0, 1)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddTriangle(0, 1, 2)
		
		'Create mesh with surface
		Local tri:Mesh = New Mesh
		tri.AddSurface(surf)
		tri.Rebuild()
		
		Return tri
	End Function
	
	Function CreateQuad:Mesh(mat:Material=Null)

'		surf.AddTriangle(v0, v1, v2)
'		surf.AddVertex(x, y, z, nx, ny, nz, color, u0, v0)
'		surf.VertexTangent(v, tx, ty, tz)
'		surf.VertexTexCoords(v, u1, v1, 1)
'		surf.VertexBone(v, 0, b0, w0)
'		surf.VertexBone(v, 1, b1, w1)
'		surf.VertexBone(v, 2, b2, w2)
'		surf.VertexBone(v, 3, b3, w3)


		Local surf:Surface = New Surface
	   'surf.AddVertex(x,       y, z, nx, ny, nz, color,      u0, v0)
		surf.AddVertex(-0.5,  0.5, 0,  0, 0, -1,  Color.White,  0, 0)
	   'surf.VertexTangent(v,                 tx, ty, tz)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddVertex( 0.5,  0.5, 0,  0, 0, -1,  Color.White,  1, 0)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddVertex(-0.5, -0.5, 0,  0, 0, -1,  Color.White,  0, 1)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddVertex( 0.5, -0.5, 0,  0, 0, -1,  Color.White,  1, 1)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddTriangle(0, 1, 2)
		surf.AddTriangle(3, 2, 1)
		
		'Create mesh with surface
		Local quad:Mesh = New Mesh
		quad.AddSurface(surf, mat)
		quad.Rebuild()
		
		Return quad
	End
	
	Function CreateCube:Mesh(mat:Material=Null)
		Local surf:Surface = New Surface
		
		'Front face
		surf.AddVertex(-0.5,  0.5, -0.5,  0, 0, -1,  Color.White,  0, 0)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddVertex( 0.5,  0.5, -0.5,  0, 0, -1,  Color.White,  1, 0)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddVertex(-0.5, -0.5, -0.5,  0, 0, -1,  Color.White,  0, 1)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddVertex( 0.5, -0.5, -0.5,  0, 0, -1,  Color.White,  1, 1)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddTriangle(0, 1, 2)
		surf.AddTriangle(3, 2, 1)
		
		'Back face
		surf.AddVertex( 0.5,  0.5, 0.5,  0, 0, 1,  Color.White,  0, 0)
		surf.VertexTangent(surf.NumVertices-1, -1, 0, 0)
		surf.AddVertex(-0.5,  0.5, 0.5,  0, 0, 1,  Color.White,  1, 0)
		surf.VertexTangent(surf.NumVertices-1, -1, 0, 0)
		surf.AddVertex( 0.5, -0.5, 0.5,  0, 0, 1,  Color.White,  0, 1)
		surf.VertexTangent(surf.NumVertices-1, -1, 0, 0)
		surf.AddVertex(-0.5, -0.5, 0.5,  0, 0, 1,  Color.White,  1, 1)
		surf.VertexTangent(surf.NumVertices-1, -1, 0, 0)
		surf.AddTriangle(4, 5, 6)
		surf.AddTriangle(7, 6, 5)
		
		'Left face
		surf.AddVertex(-0.5,  0.5,  0.5,  -1, 0, 0,  Color.White,  0, 0)
		surf.VertexTangent(surf.NumVertices-1, 0, 0, -1)
		surf.AddVertex(-0.5,  0.5, -0.5,  -1, 0, 0,  Color.White,  1, 0)
		surf.VertexTangent(surf.NumVertices-1, 0, 0, -1)
		surf.AddVertex(-0.5, -0.5,  0.5,  -1, 0, 0,  Color.White,  0, 1)
		surf.VertexTangent(surf.NumVertices-1, 0, 0, -1)
		surf.AddVertex(-0.5, -0.5, -0.5,  -1, 0, 0,  Color.White,  1, 1)
		surf.VertexTangent(surf.NumVertices-1, 0, 0, -1)
		surf.AddTriangle(8, 9, 10)
		surf.AddTriangle(11, 10, 9)
		
		'Right face
		surf.AddVertex(0.5,  0.5, -0.5,  1, 0, 0,  Color.White,  0, 0)
		surf.VertexTangent(surf.NumVertices-1, 0, 0, 1)
		surf.AddVertex(0.5,  0.5,  0.5,  1, 0, 0,  Color.White,  1, 0)
		surf.VertexTangent(surf.NumVertices-1, 0, 0, 1)
		surf.AddVertex(0.5, -0.5, -0.5,  1, 0, 0,  Color.White,  0, 1)
		surf.VertexTangent(surf.NumVertices-1, 0, 0, 1)
		surf.AddVertex(0.5, -0.5,  0.5,  1, 0, 0,  Color.White,  1, 1)
		surf.VertexTangent(surf.NumVertices-1, 0, 0, 1)
		surf.AddTriangle(12, 13, 14)
		surf.AddTriangle(15, 14, 13)
		
		'Top face
		surf.AddVertex(-0.5, 0.5,  0.5,  0, 1, 0,  Color.White,  0, 0)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddVertex( 0.5, 0.5,  0.5,  0, 1, 0,  Color.White,  1, 0)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddVertex(-0.5, 0.5, -0.5,  0, 1, 0,  Color.White,  0, 1)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddVertex( 0.5, 0.5, -0.5,  0, 1, 0,  Color.White,  1, 1)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddTriangle(16, 17, 18)
		surf.AddTriangle(19, 18, 17)
		
		'Bottom face
		surf.AddVertex(-0.5, -0.5, -0.5,  0, -1, 0,  Color.White,  0, 0)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddVertex( 0.5, -0.5, -0.5,  0, -1, 0,  Color.White,  1, 0)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddVertex(-0.5, -0.5,  0.5,  0, -1, 0,  Color.White,  0, 1)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddVertex( 0.5, -0.5,  0.5,  0, -1, 0,  Color.White,  1, 1)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddTriangle(20, 21, 22)
		surf.AddTriangle(23, 22, 21)

		'Create mesh with surface
		Local cube:Mesh = New Mesh
		cube.AddSurface(surf, mat)
		cube.Rebuild()
		
		Return cube
	End
	
	Function CreateSkybox:Mesh()
		Local surf:Surface = New Surface
		
		'Back face
		surf.AddVertex(-0.5,  0.5, -0.5,  0, 0, 1,  Color.White,  0, 0)
		surf.VertexTangent(surf.NumVertices-1, -1, 0, 0)
		surf.AddVertex( 0.5,  0.5, -0.5,  0, 0, 1,  Color.White,  1, 0)
		surf.VertexTangent(surf.NumVertices-1, -1, 0, 0)
		surf.AddVertex(-0.5, -0.5, -0.5,  0, 0, 1,  Color.White,  0, 1)
		surf.VertexTangent(surf.NumVertices-1, -1, 0, 0)
		surf.AddVertex( 0.5, -0.5, -0.5,  0, 0, 1,  Color.White,  1, 1)
		surf.VertexTangent(surf.NumVertices-1, -1, 0, 0)
		surf.AddTriangle(0, 2, 1)
		surf.AddTriangle(3, 1, 2)
		
		'Front face
		surf.AddVertex( 0.5,  0.5, 0.5,  0, 0, -1,  Color.White,  0, 0)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddVertex(-0.5,  0.5, 0.5,  0, 0, -1,  Color.White,  1, 0)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddVertex( 0.5, -0.5, 0.5,  0, 0, -1,  Color.White,  0, 1)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddVertex(-0.5, -0.5, 0.5,  0, 0, -1,  Color.White,  1, 1)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddTriangle(4, 6, 5)
		surf.AddTriangle(7, 5, 6)
		
		'Left face
		surf.AddVertex(-0.5,  0.5,  0.5,  1, 0, 0,  Color.White,  0, 0)
		surf.VertexTangent(surf.NumVertices-1, 0, 0, 1)
		surf.AddVertex(-0.5,  0.5, -0.5,  1, 0, 0,  Color.White,  1, 0)
		surf.VertexTangent(surf.NumVertices-1, 0, 0, 1)
		surf.AddVertex(-0.5, -0.5,  0.5,  1, 0, 0,  Color.White,  0, 1)
		surf.VertexTangent(surf.NumVertices-1, 0, 0, 1)
		surf.AddVertex(-0.5, -0.5, -0.5,  1, 0, 0,  Color.White,  1, 1)
		surf.VertexTangent(surf.NumVertices-1, 0, 0, 1)
		surf.AddTriangle(8, 10, 9)
		surf.AddTriangle(11, 9, 10)
		
		'Right face
		surf.AddVertex(0.5,  0.5, -0.5,  -1, 0, 0,  Color.White,  0, 0)
		surf.VertexTangent(surf.NumVertices-1, 0, 0, -1)
		surf.AddVertex(0.5,  0.5,  0.5,  -1, 0, 0,  Color.White,  1, 0)
		surf.VertexTangent(surf.NumVertices-1, 0, 0, -1)
		surf.AddVertex(0.5, -0.5, -0.5,  -1, 0, 0,  Color.White,  0, 1)
		surf.VertexTangent(surf.NumVertices-1, 0, 0, -1)
		surf.AddVertex(0.5, -0.5,  0.5,  -1, 0, 0,  Color.White,  1, 1)
		surf.VertexTangent(surf.NumVertices-1, 0, 0, -1)
		surf.AddTriangle(12, 14, 13)
		surf.AddTriangle(15, 13, 14)
		
		'Top face
		surf.AddVertex(-0.5, 0.5,  0.5,  0, -1, 0,  Color.White,  0, 0)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddVertex( 0.5, 0.5,  0.5,  0, -1, 0,  Color.White,  1, 0)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddVertex(-0.5, 0.5, -0.5,  0, -1, 0,  Color.White,  0, 1)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddVertex( 0.5, 0.5, -0.5,  0, -1, 0,  Color.White,  1, 1)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddTriangle(16, 18, 17)
		surf.AddTriangle(19, 17, 18)
		
		'Bottom face
		surf.AddVertex(-0.5, -0.5, -0.5,  0, 1, 0,  Color.White,  0, 0)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddVertex( 0.5, -0.5, -0.5,  0, 1, 0,  Color.White,  1, 0)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddVertex(-0.5, -0.5,  0.5,  0, 1, 0,  Color.White,  0, 1)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddVertex( 0.5, -0.5,  0.5,  0, 1, 0,  Color.White,  1, 1)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddTriangle(20, 22, 21)
		surf.AddTriangle(23, 21, 22)

		'Create mesh with surface
		Local skybox:Mesh = New Mesh
		skybox.AddSurface(surf)
		skybox.Rebuild()
		
		Return skybox
	End
	
	Function CreateWedge:Mesh()
		Local surf:Surface = New Surface
		
		'Back face
		surf.AddVertex( 0.5,  0.5, 0.5,  0, 0, 1,  Color.White,  0, 0)
		surf.VertexTangent(surf.NumVertices-1, -1, 0, 0)
		surf.AddVertex(-0.5,  0.5, 0.5,  0, 0, 1,  Color.White,  1, 0)
		surf.VertexTangent(surf.NumVertices-1, -1, 0, 0)
		surf.AddVertex( 0.5, -0.5, 0.5,  0, 0, 1,  Color.White,  0, 1)
		surf.VertexTangent(surf.NumVertices-1, -1, 0, 0)
		surf.AddVertex(-0.5, -0.5, 0.5,  0, 0, 1,  Color.White,  1, 1)
		surf.VertexTangent(surf.NumVertices-1, -1, 0, 0)
		surf.AddTriangle(0, 1, 2)
		surf.AddTriangle(3, 2, 1)
		
		'Left face
		surf.AddVertex(-0.5,  0.5,  0.5,  -1, 0, 0,  Color.White,  0, 0)
		surf.VertexTangent(surf.NumVertices-1, 0, 0, -1)
		surf.AddVertex(-0.5, -0.5,  0.5,  -1, 0, 0,  Color.White,  0, 1)
		surf.VertexTangent(surf.NumVertices-1, 0, 0, -1)
		surf.AddVertex(-0.5, -0.5, -0.5,  -1, 0, 0,  Color.White,  1, 1)
		surf.VertexTangent(surf.NumVertices-1, 0, 0, -1)
		surf.AddTriangle(6, 5, 4)
		
		'Right face
		surf.AddVertex(0.5,  0.5,  0.5,  1, 0, 0,  Color.White,  1, 0)
		surf.VertexTangent(surf.NumVertices-1, 0, 0, 1)
		surf.AddVertex(0.5, -0.5, -0.5,  1, 0, 0,  Color.White,  0, 1)
		surf.VertexTangent(surf.NumVertices-1, 0, 0, 1)
		surf.AddVertex(0.5, -0.5,  0.5,  1, 0, 0,  Color.White,  1, 1)
		surf.VertexTangent(surf.NumVertices-1, 0, 0, 1)
		surf.AddTriangle(9, 8, 7)
		
		'Top face
		surf.AddVertex(-0.5, 0.5,  0.5,  0, 1, 0,  Color.White,  0, 0)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddVertex( 0.5, 0.5,  0.5,  0, 1, 0,  Color.White,  1, 0)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddVertex(-0.5, -0.5, -0.5,  0, 1, 0,  Color.White, 0, 1)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddVertex( 0.5, -0.5, -0.5,  0, 1, 0,  Color.White, 1, 1)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddTriangle(10, 11, 12)
		surf.AddTriangle(13, 12, 11)
		
		'Bottom face
		surf.AddVertex(-0.5, -0.5, -0.5,  0, -1, 0,  Color.White,  0, 0)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddVertex( 0.5, -0.5, -0.5,  0, -1, 0,  Color.White,  1, 0)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddVertex(-0.5, -0.5,  0.5,  0, -1, 0,  Color.White,  0, 1)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddVertex( 0.5, -0.5,  0.5,  0, -1, 0,  Color.White,  1, 1)
		surf.VertexTangent(surf.NumVertices-1, 1, 0, 0)
		surf.AddTriangle(14, 15, 16)
		surf.AddTriangle(17, 16, 15)

		'Create mesh with surface
		Local wedge:Mesh = New Mesh
		wedge.AddSurface(surf)
		wedge.Rebuild()
		
		Return wedge
	End
	
	#Rem
	Function _Load:Mesh(filename:String, skeletonFilename:String = "", animationFilename:String = "", texFilter:Int = Renderer.FilterTrilinear)
		'Fix filenames
		Local fixedFilename:String = filename
		Local fixedSkeletonFilename:String = skeletonFilename
		Local fixedAnimationFilename:String = animationFilename
		If filename.Length > 2 And String.FromChar(filename[0]) <> "/" And String.FromChar(filename[1]) <> ":" Then fixedFilename = "cerberus://data/" + filename
		If skeletonFilename.Length > 2 And String.FromChar(skeletonFilename[0]) <> "/" And String.FromChar(skeletonFilename[1]) <> ":" Then fixedSkeletonFilename = "cerberus://data/" + skeletonFilename
		If animationFilename.Length > 2 And String.FromChar(animationFilename[0]) <> "/" And String.FromChar(animationFilename[1]) <> ":" Then fixedAnimationFilename = "cerberus://data/" + animationFilename
		
		'Load mesh data
		Local data:DataBuffer = DataBuffer.Load(fixedFilename)
		If Not data Then Return Null
		Local mesh:Mesh = Mesh._LoadData(data, filename, texFilter)
		data.Discard()
		
		'Load skeleton data
		data = DataBuffer.Load(fixedSkeletonFilename)
		If data
			mesh.LoadSkeletonData(data)
			data.Discard()
		End
		
		'Load animation data
		data = DataBuffer.Load(fixedAnimationFilename)
		If data
			mesh.LoadAnimationData(data)
			data.Discard()
		End
		
		Return mesh
	End
	#End
	
	Function _LoadData:Mesh(data:DataBuffer, filename:String, texFilter:Int = Renderer.FilterTrilinear)
		Local stream:DataStream = New DataStream(data)
		Local meshPath:String = ExtractDir(filename)
		If meshPath <> "" Then meshPath += "/"
		
		'Id
		Local id:String = stream.ReadString(4)
		If id <> "ME01" Then Return Null
		
		'Create mesh
		Local mesh:Mesh = New Mesh()
		mesh.Filename = filename
		
		'Surfaces
		Local numSurfaces:Int = stream.ReadShort() & $FFFF
		For Local s:Int = 0 Until numSurfaces
			'Material
			Local mat:Material = New Material
			Local flags:Int = 0
			mat.Color = stream.ReadInt()
			mat.Specular = stream.ReadInt()
			mat.Emissive = stream.ReadInt()
			mat.Ambient = stream.ReadInt()
			mat.BlendMode = stream.ReadByte() & $FF
			flags = stream.ReadByte() & $FF
			If flags & 1 
				mat.Culling = False 
			Else 
				mat.Culling = True
			Endif
			If flags & 2
				mat.DepthWrite = False
			Else 
			 	mat.DepthWrite = True
			Endif
			If flags & 4
				mat.Lighting = False
			Else
				mat.Lighting = True
			Endif
			If flags & 8
				mat.CastShadows = False
			Else
				mat.CastShadows = True
			Endif
			If flags & 16
				mat.ReceiveShadows = False
			Else
				mat.ReceiveShadows = True
			Endif
			If flags & 32
				mat.Fog = False
			Else
				mat.Fog = True
			Endif
			mat.SpecularPower = stream.ReadFloat()
			mat.CubeOpacity = stream.ReadFloat()
			mat.RefractionCoef = stream.ReadFloat()
			
			'Material textures
			Local usedTexs:Int = 0
			usedTexs = stream.ReadByte() & $FF
			If usedTexs & 1 'Color tex
				Local strLen:Int = stream.ReadInt()
				Local str:String = stream.ReadString(strLen)
				If str <> "" Then str = meshPath + str
				mat.ColorTexture = Texture.Load(str, texFilter)
			End
			If usedTexs & 2 'Normal tex
				Local strLen:Int = stream.ReadInt()
				Local str:String = stream.ReadString(strLen)
				If str <> "" Then str = meshPath + str
				mat.NormalTexture = Texture.Load(str, texFilter)
			End
			If usedTexs & 4 'Specular tex
				Local strLen:Int = stream.ReadInt()
				Local str:String = stream.ReadString(strLen)
				If str <> "" Then str = meshPath + str
				mat.SpecularTexture = Texture.Load(str, texFilter)
			End
			If usedTexs & 8 'Emissive
				Local strLen:Int = stream.ReadInt()
				Local str:String = stream.ReadString(strLen)
				If str <> "" Then str = meshPath + str
				mat.EmissiveTexture = Texture.Load(str, texFilter)
			End
			If usedTexs & 32 'Ambient
				Local strLen:Int = stream.ReadInt()
				Local str:String = stream.ReadString(strLen)
				If str <> "" Then str = meshPath + str
				mat.AmbientTexture = Texture.Load(str, texFilter)
			End
			If usedTexs & 64 'Cubemap
				Local strLen:Int = stream.ReadInt()
				Local cubeTexs:String[] = stream.ReadString(strLen).Split(",")
				For Local t:Int = 0 Until cubeTexs.Length
					If cubeTexs[t] <> "" Then cubeTexs[t] = meshPath + cubeTexs[t]
				Next
				mat.CubeTexture = Texture.Load(cubeTexs[0], cubeTexs[1], cubeTexs[2], cubeTexs[3], cubeTexs[4], cubeTexs[5], texFilter)
			End
			
			'Surface
			Local surf:Surface = New Surface
			
			'Number of indices, vertices and vertex flags
			Local numIndices:Int = stream.ReadInt()
			Local numVertices:Int = stream.ReadShort() & $FFFF
			Local vertexFlags:Int = stream.ReadByte() & $FF
			
			'Indices
			For Local i:Int = 0 Until numIndices Step 3
				Local v0:Int = stream.ReadShort() & $FFFF
				Local v1:Int = stream.ReadShort() & $FFFF
				Local v2:Int = stream.ReadShort() & $FFFF
				surf.AddTriangle(v0, v1, v2)
			Next
			
			'Vertices
			For Local v:Int = 0 Until numVertices
				'Load vertices
				Local x:Float = stream.ReadFloat()
				Local y:Float = stream.ReadFloat()
				Local z:Float = stream.ReadFloat()
				
				'Load normals if present
				Local nx:Float = 0
				Local ny:Float = 0
				Local nz:Float = 0
				If vertexFlags & 1 = 1
					nx = stream.ReadFloat()
					ny = stream.ReadFloat()
					nz = stream.ReadFloat()
				End
				
				'Load tangents if present
				Local tx:Float = 0
				Local ty:Float = 0
				Local tz:Float = 0
				If vertexFlags & 2 = 2
					tx = stream.ReadFloat()
					ty = stream.ReadFloat()
					tz = stream.ReadFloat()
				End
				
				'Load colors if present
				Local color:Int = Color.White
				If vertexFlags & 4 = 4 Then color = stream.ReadInt()
				
				'Load texcoords0 if present
				Local u0:Float = 0
				Local v0:Float = 0
				If vertexFlags & 8 = 8
					u0 = stream.ReadFloat()
					v0 = stream.ReadFloat()
				End
				
				'Load texcoords1 if present
				Local u1:Float = u0
				Local v1:Float = v0
				If vertexFlags & 16 = 16
					u1 = stream.ReadFloat()
					v1 = stream.ReadFloat()
				End
				
				'Load bones if present
				Local b0:Int = -1
				Local b1:Int = -1
				Local b2:Int = -1
				Local b3:Int = -1
				Local w0:Float = 0
				Local w1:Float = 0
				Local w2:Float = 0
				Local w3:Float = 0
				If vertexFlags & 32 = 32
					b0 = stream.ReadShort() & $FFFF
					b1 = stream.ReadShort() & $FFFF
					b2 = stream.ReadShort() & $FFFF
					b3 = stream.ReadShort() & $FFFF
					w0 = stream.ReadFloat()
					w1 = stream.ReadFloat()
					w2 = stream.ReadFloat()
					w3 = stream.ReadFloat()
				End
				
				surf.AddVertex(x, y, z, nx, ny, nz, color, u0, v0)
				surf.VertexTangent(v, tx, ty, tz)
				surf.VertexTexCoords(v, u1, v1, 1)
				surf.VertexBone(v, 0, b0, w0)
				surf.VertexBone(v, 1, b1, w1)
				surf.VertexBone(v, 2, b2, w2)
				surf.VertexBone(v, 3, b3, w3)
			Next
			
			'Add to mesh
			mesh.AddSurface(surf, mat)
		Next
		
		stream.Close()
		
		mesh.Rebuild()
		
		Return mesh
	End
	
	Function _LoadData_OBJ:Mesh(filename:String, texFilter:Int = Renderer.FilterTrilinear)
		Local v  := New FloatStack
		Local vt := New FloatStack
		Local vn := New FloatStack
		Local meshPath:String = ExtractDir(filename)
		Local materialPath:String  = ExtractDir(filename)
		Local texturePath:String  = ExtractDir(filename)
		Local texturefile:String  = ""
		If meshPath <> "" Then meshPath += "/"
		Local matMap:StringMap<Material> = New StringMap<Material>()
		'Create mesh
		Local mesh:Mesh = New Mesh()
		mesh.Filename = filename


		'Material
'		Local mat:Material = New Material
'		
'		mat.Culling = True
'		mat.DepthWrite = True
'		mat.Lighting = True
'		mat.CastShadows = True
'		mat.ReceiveShadows = True
'		mat.Fog = True
'
'		mat.Color=-1
'		mat.BlendMode=0
'		mat.Shininess=1
'		mat.SpecularPower=64
'		mat.CubeOpacity=0.5
'		mat.RefractionCoef=-1
		
		'Surface
		Local surf:Surface = New Surface
		Local mat:Material
		Local matuse:Material
		Local matname:String=""
		Local vtCnt:Int = 0				
'Print "Load OBJ file:"+filename
		
		For Local line := Eachin LoadString( filename ).Split( "~n" )
		
			line = line.Trim()
			line = line.Replace("  ", " ")
			If Not line Or line.StartsWith( "#" ) Continue
			
'Print "line = "+line
			
			Local bits := line.Split( " " )
			Select bits[0]
				Case "mtllib"        'Material file
					materialPath += "/"+bits[1]
'Print "mtllib = "+materialPath
					'Load Material file	
					
					Local matlines:= LoadString(materialPath).Split("~n")
					For Local matline := Eachin matlines
						Local matbits := matline.Split(" ")
						Select matbits[0]
							Case "newmtl"
								If matname.Length()>0
									matMap.Add(matname,mat)
								Endif
								matname = matbits[1]
'Print "matname = "+ matname
								mat = New Material
								
								mat.Culling = False
								mat.DepthWrite = True
								mat.Lighting = True
								mat.CastShadows = True
								mat.ReceiveShadows = True
								mat.Fog = True
						
								mat.BlendMode=0
								mat.Shininess=0  '1
								mat.RefractionCoef=-1
								mat.SpecularPower=64
								mat.CubeOpacity=0.5
							Case "Ns"       'specular highlights
							Case "Ka"       'ambient color
							Case "Kd"       'diffuse color
								'mat.Color = -1
								mat.Color=(Float(matbits[1])*255.0) Shl 16 +(Float(matbits[2])*255.0) Shl 8+(Float(matbits[3])*255.0)
'Print "mat color = "+matbits[1]+ " : " +matbits[2] +" : "+matbits[3]
'Print "mat color = "+mat.Color()
							Case "Ks"       'specular color
							Case "Ke"	    'emissive color
							Case "Ni"       'optical density
							Case "d"        'dissolve
							Case "illum"    'illumination model
							Case "map_Kd"   'color texture file 
								texturefile = "/"+matbits[1].Trim()
'Print "mat texturefile = <"+texturefile+">"
								mat.ColorTexture = Texture.Load(texturePath+texturefile, texFilter)
						End
					Next
					matMap.Add(matname,mat)
					
				Case "usemtl"        'Select the specified material
					If surf.NumTriangles()> 0
						mesh.AddSurface(surf,matuse)
'Print "usemtl <<<< mesh.AddSurface <<<< "+matname	+"    <<<<<< "+ surf.NumTriangles()		+" : " +surf.NumVertices()		+" : "+surf.NumIndices()		
						'mesh.Rebuild()
						surf = 	New Surface
						vtCnt = 0	
					Endif

					matname = bits[1]
					matuse = matMap.Get(matname) 
'Print "usemtl = " + matname + " : "+matuse.Color
				Case "v"
					' List of geometric vertices, with (x, y, z [,w]) coordinates, w is optional and defaults to 1.0.
	  				' v 0.123 0.234 0.345 1.0			
					If bits.Length() = 4 Or bits.Length() = 5
						v.Push( Float( bits[1] ))
						v.Push( Float( bits[2] ))
						v.Push( Float( bits[3] ))
				'Print(Float( bits[1])+":"+Float( bits[2])+":"+Float( bits[3]))
					Else
						Error ("OBJ error - Vertex count ("+(bits.Length()-1)+")")
					Endif
	
				Case "vn"
					' List of vertex normals in (x,y,z) form; normals might not be unit vectors.
					' vn 0.707 0.000 0.707
					If bits.Length() = 4
						vn.Push( Float( bits[1] ))
						vn.Push( Float( bits[2] ))
						vn.Push( Float( bits[3] ))
					Else
						Error "OBJ error - Vertex normals count ("+(bits.Length()-1)+")"
					Endif
					
				Case "vt"
					' List of texture coordinates, in (u, [,v ,w]) coordinates, these will vary between 0 and 1. v, w are optional and default to 0.
					' vt 0.500 1 [0]
					If bits.Length() = 3 Or bits.Length() = 4
						vt.Push( Float( bits[1] ))
						vt.Push( 1.0-Float( bits[2] ))
					Else
						Error "OBJ error - Texture coordinates count ("+(bits.Length()-1)+")"
					Endif
				Case "vp"
					' Parameter space vertices in ( u [,v] [,w] ) form; free form geometry statement ( see below )
					' vp 0.310000 3.210000 2.100000				
					
				Case "f"
					' Polygonal face element  (vertex/texture/normal)    Quards have one more entry
					'  f 1 2 3
					'  f 3/1 4/2 5/3
					'  f 6/4/1 3/5/3 7/6/5
					'  f 7//1 8//2 9//3
'Print line
					If bits.Length() = 4       'Triangle
						For Local i:Int = 1 To 3
							Local bits2 := bits[i].Split( "/" )
							Local vi:Int = -1
							Local vti:Int = -1
							Local vni:Int = -1
							Select bits2.Length()
								Case 1
									vi  = (Int(bits2[0])-1)*3
									surf.AddVertex( v.Get(vi),v.Get(vi+1),v.Get(vi+2),1.0,0.0,0.0,Color.White,0.0,0.0)
									vtCnt += 1
								Case 2
									vi  = (Int(bits2[0])-1)*3
									vti = (Int(bits2[1])-1)*2
									surf.AddVertex( v.Get(vi),v.Get(vi+1),v.Get(vi+2),1.0,0.0,0.0,Color.White,vt.Get(vti),vt.Get(vti+1))
									vtCnt += 1
								Case 3
									vi  = (Int(bits2[0])-1)*3
									If bits[1].Length()>0
										vti = (Int(bits2[1])-1)*2
										vni = (Int(bits2[2])-1)*3
										surf.AddVertex( v.Get(vi),v.Get(vi+1),v.Get(vi+2),vn.Get(vni),vn.Get(vni+1),vn.Get(vni+2),Color.White,vt.Get(vti),vt.Get(vti+1))
										vtCnt += 1
									Else
										vni = (Int(bits2[2])-1)*3
										surf.AddVertex( v.Get(vi),v.Get(vi+1),v.Get(vi+2),vn.Get(vni),vn.Get(vni+1),vn.Get(vni+2),Color.White,0.0,0.0)
										vtCnt += 1
									Endif
							End
						Next
						Local v0:= vtCnt-3
						Local v1:= vtCnt-2
						Local v2:= vtCnt-1
						surf.AddTriangle(v0, v1, v2)
					Elseif bits.Length() = 5       'Quard
						For Local i:Int = 1 To 4
							Local bits2 := bits[i].Split( "/" )
							Local vi:Int = -1
							Local vti:Int = -1
							Local vni:Int = -1
							Select bits2.Length()
								Case 1
									vi  = (Int(bits2[0])-1)*3
									surf.AddVertex( v.Get(vi),v.Get(vi+1),v.Get(vi+2),1.0,0.0,0.0,Color.White,0.0,0.0)
									vtCnt += 1
								Case 2
									vi  = (Int(bits2[0])-1)*3
									vti = (Int(bits2[1])-1)*2
									surf.AddVertex( v.Get(vi),v.Get(vi+1),v.Get(vi+2),1.0,0.0,0.0,Color.White,vt.Get(vti),vt.Get(vti+1))
									vtCnt += 1
								Case 3
									vi  = (Int(bits2[0])-1)*3
									If bits[1].Length()>0
										vti = (Int(bits2[1])-1)*2
										vni = (Int(bits2[2])-1)*3
										surf.AddVertex( v.Get(vi),v.Get(vi+1),v.Get(vi+2),vn.Get(vni),vn.Get(vni+1),vn.Get(vni+2),Color.White,vt.Get(vti),vt.Get(vti+1))
										vtCnt += 1
									Else
										vni = (Int(bits2[2])-1)*3
										surf.AddVertex( v.Get(vi),v.Get(vi+1),v.Get(vi+2),vn.Get(vni),vn.Get(vni+1),vn.Get(vni+2),Color.White,0.0,0.0)
										vtCnt += 1
									Endif
							End
						Next
						Local v0:= vtCnt-4
						Local v1:= vtCnt-3
						Local v2:= vtCnt-2
						Local v3:= vtCnt-1
						surf.AddTriangle(v0, v1, v2)
						surf.AddTriangle(v0, v2, v3)
					Else
						Error "OBJ error - Polygon face element count ("+(bits.Length()-1)+")"
					Endif
				Case "s"
				Case "o"
				Case "g"
				Default
					Error "obj error 6("+line+")"
			End
		Next
		
'		surf.AddTriangle(v0, v1, v2)
'		surf.AddVertex(x, y, z, nx, ny, nz, color, u0, v0)
'		surf.VertexTangent(v, tx, ty, tz)
'		surf.VertexTexCoords(v, u1, v1, 1)
'		surf.VertexBone(v, 0, b0, w0)
'		surf.VertexBone(v, 1, b1, w1)
'		surf.VertexBone(v, 2, b2, w2)
'		surf.VertexBone(v, 3, b3, w3)

		'Add to mesh
'Print "       <<<< mesh.AddSurface <<<< "+matname	+"    <<<<<< "+ surf.NumTriangles()				+" : " +surf.NumVertices()	+" : "+surf.NumIndices()
	
		mesh.AddSurface(surf,matuse)
'Print "NumSurfaces = "+mesh.NumSurfaces()		
		mesh.Rebuild()

		Return mesh

	End
	
#rem	
	Function _LoadData_OBJ_old:Mesh(data:DataBuffer, filename:String, texFilter:Int = Renderer.FilterTrilinear)
		Local v  := New FloatStack
		Local vt := New FloatStack
		Local vn := New FloatStack
		Local meshPath:String = ExtractDir(filename)
		Local materialPath:String  = ExtractDir(filename)
		Local texturePath:String  = ExtractDir(filename)
		Local texturefile:String  = ""
		If meshPath <> "" Then meshPath += "/"

		'Create mesh
		Local mesh:Mesh = New Mesh()
		mesh.Filename = filename
		'Material
		Local mat:Material = New Material
		
		mat.Culling = True
		mat.DepthWrite = True
		mat.Lighting = True
		mat.CastShadows = True
		mat.ReceiveShadows = True
		mat.Fog = True

		mat.Color=-1
		mat.BlendMode=0
		mat.Shininess=1
		mat.SpecularPower=64
		mat.CubeOpacity=0.5
		mat.RefractionCoef=-1
		
		'Surface
		Local surf:Surface = New Surface
		Local vtCnt:Int = 0				
Print "Load OBJ file:"+filename
		
		For Local line := Eachin LoadString( filename ).Split( "~n" )
		
			line = line.Trim()
			If Not line Or line.StartsWith( "#" ) Continue
			
'Print line
			
			Local bits := line.Split( " " )
			Select bits[0]
			Case "v"
				' List of geometric vertices, with (x, y, z [,w]) coordinates, w is optional and defaults to 1.0.
  				' v 0.123 0.234 0.345 1.0			
				If bits.Length() = 4 Or bits.Length() = 5
					v.Push( Float( bits[1] ))
					v.Push( Float( bits[2] ))
					v.Push( Float( bits[3] ))
				Else
					Error ("OBJ error - Vertex count ("+(bits.Length()-1)+")")
				Endif

			Case "vn"
				' List of vertex normals in (x,y,z) form; normals might not be unit vectors.
				' vn 0.707 0.000 0.707
				If bits.Length() = 4
					vn.Push( Float( bits[1] ))
					vn.Push( Float( bits[2] ))
					vn.Push( Float( bits[3] ))
				Else
					Error "OBJ error - Vertex normals count ("+(bits.Length()-1)+")"
				Endif
				
			Case "vt"
				' List of texture coordinates, in (u, [,v ,w]) coordinates, these will vary between 0 and 1. v, w are optional and default to 0.
				' vt 0.500 1 [0]
				If bits.Length() = 3 Or bits.Length() = 4
					vt.Push( Float( bits[1] ))
					vt.Push( 1.0-Float( bits[2] ))
				Else
					Error "OBJ error - Texture coordinates count ("+(bits.Length()-1)+")"
				Endif
			Case "vp"
				' Parameter space vertices in ( u [,v] [,w] ) form; free form geometry statement ( see below )
				' vp 0.310000 3.210000 2.100000				
				
			Case "f"
				' Polygonal face element  (vertex/texture/normal)    Quards have one more entry
				'  f 1 2 3
				'  f 3/1 4/2 5/3
				'  f 6/4/1 3/5/3 7/6/5
				'  f 7//1 8//2 9//3
				If bits.Length() = 4       'Triangle
					For Local i:Int = 1 To 3
						Local bits2 := bits[i].Split( "/" )
						Local vi:Int = -1
						Local vti:Int = -1
						Local vni:Int = -1
						Select bits2.Length()
							Case 1
								vi  = (Int(bits2[0])-1)*3
								surf.AddVertex( v.Get(vi),v.Get(vi+1),v.Get(vi+2),1.0,0.0,0.0,Color.White,0.0,0.0)
								vtCnt += 1
							Case 2
								vi  = (Int(bits2[0])-1)*3
								vti = (Int(bits2[1])-1)*2
								surf.AddVertex( v.Get(vi),v.Get(vi+1),v.Get(vi+2),1.0,0.0,0.0,Color.White,vt.Get(vti),vt.Get(vti+1))
								vtCnt += 1
							Case 3
								vi  = (Int(bits2[0])-1)*3
								If bits[1].Length()>0
									vti = (Int(bits2[1])-1)*2
									vni = (Int(bits2[2])-1)*3
									surf.AddVertex( v.Get(vi),v.Get(vi+1),v.Get(vi+2),vn.Get(vni),vn.Get(vni+1),vn.Get(vni+2),Color.White,vt.Get(vti),vt.Get(vti+1))
									vtCnt += 1
								Else
									vni = (Int(bits2[2])-1)*3
									surf.AddVertex( v.Get(vi),v.Get(vi+1),v.Get(vi+2),vn.Get(vni),vn.Get(vni+1),vn.Get(vni+2),Color.White,0.0,0.0)
									vtCnt += 1
								Endif
						End
					Next
					Local v0:= vtCnt-3
					Local v1:= vtCnt-2
					Local v2:= vtCnt-1
					surf.AddTriangle(v0, v1, v2)
				Elseif bits.Length() = 5       'Quard
					For Local i:Int = 1 To 4
						Local bits2 := bits[i].Split( "/" )
						Local vi:Int = -1
						Local vti:Int = -1
						Local vni:Int = -1
						Select bits2.Length()
							Case 1
								vi  = (Int(bits2[0])-1)*3
								surf.AddVertex( v.Get(vi),v.Get(vi+1),v.Get(vi+2),1.0,0.0,0.0,Color.White,0.0,0.0)
								vtCnt += 1
							Case 2
								vi  = (Int(bits2[0])-1)*3
								vti = (Int(bits2[1])-1)*2
								surf.AddVertex( v.Get(vi),v.Get(vi+1),v.Get(vi+2),1.0,0.0,0.0,Color.White,vt.Get(vti),vt.Get(vti+1))
								vtCnt += 1
							Case 3
								vi  = (Int(bits2[0])-1)*3
								If bits[1].Length()>0
									vti = (Int(bits2[1])-1)*2
									vni = (Int(bits2[2])-1)*3
									surf.AddVertex( v.Get(vi),v.Get(vi+1),v.Get(vi+2),vn.Get(vni),vn.Get(vni+1),vn.Get(vni+2),Color.White,vt.Get(vti),vt.Get(vti+1))
									vtCnt += 1
								Else
									vni = (Int(bits2[2])-1)*3
									surf.AddVertex( v.Get(vi),v.Get(vi+1),v.Get(vi+2),vn.Get(vni),vn.Get(vni+1),vn.Get(vni+2),Color.White,0.0,0.0)
									vtCnt += 1
								Endif
						End
					Next
					Local v0:= vtCnt-4
					Local v1:= vtCnt-3
					Local v2:= vtCnt-2
					Local v3:= vtCnt-1
					surf.AddTriangle(v0, v1, v2)
					surf.AddTriangle(v0, v2, v3)
				Else
					Error "OBJ error - Polygon face element count ("+(bits.Length()-1)+")"
				Endif
			Case "mtllib"        'Material file
				materialPath += "/"+bits[1]
				Print "materialPath = "+materialPath
			Case "usemtl"        'Select the specified material
				'
			Case "s"
			Case "o"
			Case "g"
			Default
				Error "obj error 6("+line+")"
			End
		Next
		
'		surf.AddTriangle(v0, v1, v2)
'		surf.AddVertex(x, y, z, nx, ny, nz, color, u0, v0)
'		surf.VertexTangent(v, tx, ty, tz)
'		surf.VertexTexCoords(v, u1, v1, 1)
'		surf.VertexBone(v, 0, b0, w0)
'		surf.VertexBone(v, 1, b1, w1)
'		surf.VertexBone(v, 2, b2, w2)
'		surf.VertexBone(v, 3, b3, w3)

		

				
		'Load Material	
		Local matlines:= LoadString(materialPath).Split("~n")
		For Local matline := Eachin matlines
			Local matbits := matline.Split(" ")
			Select matbits[0]
				Case "map_Kd"
					texturefile = "/"+matbits[1]
					Print "texturefile = "+texturefile
					
			End
		Next
		mat.ColorTexture = Texture.Load(texturePath+texturefile, texFilter)
		
		'Add to mesh
		mesh.AddSurface(surf,mat)
		'mesh.AddSurface(surf)
		
		mesh.Rebuild()

		Return mesh

	End

#end

	Method _LoadSkeletonData:Bool(data:DataBuffer)
		If Not data Then Return False
		Local stream:DataStream = New DataStream(data)
		
		'Id
		Local id:String = stream.ReadString(4)
		If id <> "SK01" Then Return False
		
		'Number of bones
		Local numBones:Int = stream.ReadShort() & $FFFF
		
		'Bones
		For Local b:Int = 0 Until numBones
			'Name
			Local nameLen:Int = stream.ReadInt()
			Local name:String = stream.ReadString(nameLen)
			
			'Parent index
			Local parentIndex:Int = stream.ReadInt()
			
			'Create bone
			Local bone:Bone = New Bone(name, parentIndex)
			
			'Transform matrix
			For Local i:Int = 0 Until 16
				bone.TransformMatrix[i] = stream.ReadFloat()
			Next
			
			'Inv pose matrix
			For Local i:Int = 0 Until 16
				bone.InversePoseMatrix[i] = stream.ReadFloat()
			Next
			
			'Surfaces
			bone.NumSurfaces = stream.ReadShort() & $FFFF
			For Local i:Int = 0 Until bone.NumSurfaces
				bone.SurfaceIndex(i, stream.ReadShort() & $FFFF)
			Next
			
			'Add to hierarchy
			AddBone(bone)
		Next
		
		Return True
	End
	
	Method _LoadAnimationData:Bool(data:DataBuffer, sequenceName:String)
		If Not data Then Return False
		Local stream:DataStream = New DataStream(data)
		
		'Id
		Local id:String = stream.ReadString(4)
		If id <> "AN01" Then Return False
		
		'Get first frame and last frame
		Local firstFrame:Int = NumFrames
		Local lastFrame:Int = firstFrame
		
		'Number of frames
		Local numFrames:Int = stream.ReadShort() & $FFFF
		
		'Animation speed in FPS
		Local animFps:Float = stream.ReadFloat()
		
		'Number of bones
		Local numBones:Int = stream.ReadShort() & $FFFF
		
		'Bone animations
		For Local i:Int = 0 Until numBones
			'Position keys
			Local numKeys:Int = stream.ReadShort() & $FFFF
			For Local k:Int = 0 Until numKeys
				Local frame:Int = stream.ReadShort() & $FFFF
				lastFrame = Max(lastFrame, frame + firstFrame)
				Local x:Float = stream.ReadFloat()
				Local y:Float = stream.ReadFloat()
				Local z:Float = stream.ReadFloat()
				Bone(i).AddPositionKey(firstFrame + frame, x, y, z)
			Next
			
			'Rotation keys
			numKeys = stream.ReadShort() & $FFFF
			For Local k:Int = 0 Until numKeys
				Local frame:Int = stream.ReadShort() & $FFFF
				lastFrame = Max(lastFrame, frame + firstFrame)
				Local w:Float = stream.ReadFloat()
				Local x:Float = stream.ReadFloat()
				Local y:Float = stream.ReadFloat()
				Local z:Float = stream.ReadFloat()
				Bone(i).AddRotationKey(firstFrame + frame, w, x, y, z)
			Next
			
			'Scale keys
			numKeys = stream.ReadShort() & $FFFF
			For Local k:Int = 0 Until numKeys
				Local frame:Int = stream.ReadShort() & $FFFF
				lastFrame = Max(lastFrame, frame + firstFrame)
				Local x:Float = stream.ReadFloat()
				Local y:Float = stream.ReadFloat()
				Local z:Float = stream.ReadFloat()
				Bone(i).AddScaleKey(firstFrame + frame, x, y, z)
			Next
		Next
		
		mSequences = mSequences.Resize(mSequences.Length + 1)
		mSequences[mSequences.Length - 1] = New AnimSequence(sequenceName, animFps, firstFrame, lastFrame)
		
		Return True
	End
	
	Method _LoadVertexAnimationData:Bool(data:DataBuffer, sequenceName:String)
		If Not data Then Return False
		Local stream:DataStream = New DataStream(data)
		
		'Id
		Local id:String = stream.ReadString(4)
		If id <> "VA01" Then Return False
		
		'Animation speed
		Local animFps:Float = stream.ReadFloat()
		
		'Number of surfaces
		Local numSurfaces:Int = stream.ReadShort()
		If numSurfaces <> NumSurfaces Then Return False
		
		'Get first frame and last frame
		Local firstFrame:Int = NumFrames
		Local lastFrame:Int = firstFrame
		
		'Surfaces
		For Local s:Int = 0 Until numSurfaces
			Local surf:Surface = Surface(s)
		
			'Number of frames
			Local numFrames:Int = stream.ReadShort()
			
			'Frames
			For Local f:Int = 0 Until numFrames
				'Create buffers
				Local positions:DataBuffer = New DataBuffer(surf.NumVertices * 12)
				Local normals:DataBuffer = New DataBuffer(surf.NumVertices * 12)
			
				'Frame
				Local frame:Int = stream.ReadShort()
				lastFrame = Max(lastFrame, frame + firstFrame)
				
				'Positions
				For Local p:Int = 0 Until surf.NumVertices
					positions.PokeFloat(p*12, stream.ReadFloat())
					positions.PokeFloat(p*12 + 4, stream.ReadFloat())
					positions.PokeFloat(p*12 + 8, stream.ReadFloat())
				Next
				
				'Normals
				For Local n:Int = 0 Until surf.NumVertices
					normals.PokeFloat(n*12, stream.ReadFloat())
					normals.PokeFloat(n*12 + 4, stream.ReadFloat())
					normals.PokeFloat(n*12 + 8, stream.ReadFloat())
				Next
				
				surf._AddVertexFrame(frame + firstFrame, positions, normals)
				positions.Discard()
				normals.Discard()
			Next
		Next
		
		mSequences = mSequences.Resize(mSequences.Length + 1)
		mSequences[mSequences.Length - 1] = New AnimSequence(sequenceName, animFps, firstFrame, lastFrame)
		
		Return True
	End
	
	#Rem
	Method _Animate:Void(animMatrices:Float[][], frame:Float, firstFrame:Int = 0, lastFrame:Int = 0)
		'We can only animate if the mesh has bones
		If mBones.Length() > 0
			'If we have not specified the ending frame of the sequence, take the last frame in the entire animation
			If lastFrame = 0 Then lastFrame = NumFrames
			
			'Calculate animation matrix for all bones
			For Local i:Int = 0 Until NumBones
				Bone(i).CalculateAnimMatrix(animMatrices[i], frame, firstFrame, lastFrame)
				If Bone(i).ParentIndex > -1
					Mat4MulSafe(animMatrices[Bone(i).ParentIndex], animMatrices[i], animMatrices[i])
				End
			Next
			
			'Multiply every animation matrix by the inverse of the pose matrix
			For Local i:Int = 0 Until NumBones
				Mat4Mul(animMatrices[i], Bone(i).InversePoseMatrix, animMatrices[i])
			Next
		End
	End
	#End
	
	Method _AnimateVertices:Void(frame:Float, firstFrame:Int = 0, lastFrame:Int = 0)
		'If we have not specified the ending frame of the sequence, take the last frame in the entire animation
		If lastFrame = 0 Then lastFrame = NumFrames
		
		'Animate all surfaces
		For Local surf:Surface = Eachin mSurfaces
			surf._AnimateVertices(frame, firstFrame, lastFrame)
		Next
	End
	
	Method _AnimSeqIndex:Int(name:String)
		For Local i:Int = 0 Until mSequences.Length
			If mSequences[i].mName = name Then Return i
		Next
		Return -1
	End
	
	Method _AnimSeqFps:Float(index:Int)
		Return mSequences[index].mFps
	End
	
	Method _AnimSeqFirstFrame:Int(index:Int)
		Return mSequences[index].mFirstFrame
	End
	
	Method _AnimSeqLastFrame:Int(index:Int)
		Return mSequences[index].mLastFrame
	End
Private
	Field mFilename		: String
	Field mSurfaces		: Surface[]
	Field mMaterials	: Material[]
	Field mBones			: Bone[]
	Field mSequences	: AnimSequence[]
	'Field mNumFrames	: Int
	'Field mAnimSpeed	: Float
	Field mBoxMin			: Float[3]
	Field mBoxMax			: Float[3]
End

Private

Class AnimSequence
	Method New(name:String, fps:Float, firstFrame:Int, lastFrame:Int)
		mName = name
		mFps = fps
		mFirstFrame = firstFrame
		mLastFrame = lastFrame
	End
Private
	Field	mName				: String
	Field mFps				: Float
	Field mFirstFrame	: Int
	Field mLastFrame	: Int
	
	Method New()
	End
End
