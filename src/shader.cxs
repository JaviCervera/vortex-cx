Strict

Private
Import color
Import math3d
Import renderer
Import renderstate
Import shader_code

Private

Class ShaderUniforms
Public
	Field mModelViewProjection:Int
	Field mModelView:Int
	Field mInverseView:Int
	Field mNormalMatrix:Int
	Field mTextureMatrix:Int
	Field mDepthBiasMatrix:Int
	Field mSolidMode:Int
	'Field mFlags:Int
	Field mUseColorTex:Int
	Field mUseAmbientTex:Int
	Field mUseSpecularTex:Int
	Field mUseEmissiveTex:Int
	Field mUseNormalTex:Int
	Field mUseCubemap:Int
	Field mBaseTexSampler:Int
	Field mAmbientTexSampler:Int
	Field mSpecularTexSampler:Int
	Field mEmissiveTexSampler:Int
	Field mNormalTexSampler:Int
	Field mCubemapSampler:Int
	Field mDepthSampler:Int
	Field mNumLights:Int
	Field mLightVector:Int[Renderer.MaxLights()]
	Field mLightData:Int[Renderer.MaxLights()]
	Field mMaterialColor:Int
	Field mAmbient:Int
	Field mSpecular:Int
	Field mEmissive:Int
	Field mMaterialSpecularPower:Int
	Field mCubeOpacity:Int
	Field mRefractCoef:Int
	Field mFogData:Int
	Field mFogColor:Int
	Field mShadowsEnabled:Int
	Field mDepthEpsilon:Int
	Field mSkinned:Int
	Field mBones:Int[Renderer.MaxBones()]
	
	Method New(shader:Int)
		mModelViewProjection = Renderer.ShaderLocation(shader, "ModelViewProjection")
		mModelView = Renderer.ShaderLocation(shader, "ModelView")
		mInverseView = Renderer.ShaderLocation(shader, "InverseView")
		mNormalMatrix = Renderer.ShaderLocation(shader, "NormalMatrix")
		mTextureMatrix = Renderer.ShaderLocation(shader, "TextureMatrix")
		mDepthBiasMatrix = Renderer.ShaderLocation(shader, "DepthBiasMatrix")
		mSolidMode = Renderer.ShaderLocation(shader, "SolidMode")
		'mFlags = Renderer.ShaderLocation(shader, "Flags")
		mUseColorTex = Renderer.ShaderLocation(shader, "UseColorTex")
		mUseAmbientTex = Renderer.ShaderLocation(shader, "UseAmbientTex")
		mUseSpecularTex = Renderer.ShaderLocation(shader, "UseSpecularTex")
		mUseEmissiveTex = Renderer.ShaderLocation(shader, "UseEmissiveTex")
		mUseNormalTex = Renderer.ShaderLocation(shader, "UseNormalTex")
		mUseCubemap = Renderer.ShaderLocation(shader, "UseCubemap")
		mNumLights = Renderer.ShaderLocation(shader, "NumLights")
		For Local i:Int = 0 Until Renderer.MaxLights()
			mLightVector[i] = Renderer.ShaderLocation(shader, "Lights[" + i + "].Vector")
			mLightData[i] = Renderer.ShaderLocation(shader, "Lights[" + i + "].Data")
		Next
		mMaterialColor = Renderer.ShaderLocation(shader, "MaterialColor")
		mAmbient = Renderer.ShaderLocation(shader, "Ambient")
		mSpecular = Renderer.ShaderLocation(shader, "Specular")
		mEmissive = Renderer.ShaderLocation(shader, "Emissive")
		mMaterialSpecularPower = Renderer.ShaderLocation(shader, "MaterialSpecularPower")
		mCubeOpacity = Renderer.ShaderLocation(shader, "CubeOpacity")
		mRefractCoef = Renderer.ShaderLocation(shader, "MaterialRefractCoef")
		mFogData = Renderer.ShaderLocation(shader, "Fog.Data")
		mFogColor = Renderer.ShaderLocation(shader, "Fog.Color")
		mShadowsEnabled = Renderer.ShaderLocation(shader, "ShadowsEnabled")
		mDepthEpsilon = Renderer.ShaderLocation(shader, "DepthEpsilon")
		mSkinned = Renderer.ShaderLocation(shader, "Skinned")
		For Local i:Int = 0 Until Renderer.MaxBones()
			mBones[i] = Renderer.ShaderLocation(shader, "Bones[" + i + "]")
		Next
		mBaseTexSampler = Renderer.ShaderLocation(shader, "BaseTexSampler")
		mAmbientTexSampler = Renderer.ShaderLocation(shader, "AmbientTexSampler")
		mSpecularTexSampler = Renderer.ShaderLocation(shader, "SpecularTexSampler")
		mEmissiveTexSampler = Renderer.ShaderLocation(shader, "EmissiveTexSampler")
		mNormalTexSampler = Renderer.ShaderLocation(shader, "NormalTexSampler")
		mCubemapSampler = Renderer.ShaderLocation(shader, "CubemapSampler")
		mDepthSampler = Renderer.ShaderLocation(shader, "DepthSampler")
	End
	
	Method Prepare:Void()
		'Calculate ModelView
		If mModelView <> -1 Or mNormalMatrix <> -1
			Mat4Mul(RenderState.ViewMatrix, RenderState.ModelMatrix, mTempMatrix)
			Renderer.SetShaderMat4(mModelView, mTempMatrix)
		End

		'Calculate normal
		If mNormalMatrix <> -1
			Mat4Invert(mTempMatrix, mTempMatrix)
			Mat4Transpose(mTempMatrix, mTempMatrix)
			Renderer.SetShaderMat4(mNormalMatrix, mTempMatrix)
		End
		
		'Calculate inverse view
		If mInverseView <> -1
			Mat4Invert(RenderState.ViewMatrix, mTempMatrix)
			Renderer.SetShaderMat4(mInverseView, mTempMatrix)
		End

		'Calculate ModelViewProjection
		If mModelViewProjection <> -1
			Mat4Mul(RenderState.ProjectionMatrix, RenderState.ViewMatrix, mTempMatrix)
			Mat4Mul(mTempMatrix, RenderState.ModelMatrix, mTempMatrix)
			Renderer.SetShaderMat4(mModelViewProjection, mTempMatrix)
		End
		
		'Calculate depth bias
		If mDepthBiasMatrix <> -1
			Mat4Mul(RenderState.DepthBiasMatrix, RenderState.ModelMatrix, mTempMatrix)
			Renderer.SetShaderMat4(mDepthBiasMatrix, mTempMatrix)
		End
		
		'Set flags (commented right now because GLSL versions < 1.3 do not support bitwise operators)
		#Rem
		If mFlags <> -1
			Local flags:Int = 0
			If RenderState.BaseTexMode <> 0 Then flags |= Shader.FlagBaseTex
			If RenderState.UseNormalTex Then flags |= Shader.FlagNormalTex
			If RenderState.UseShininessTex Then flags |= Shader.FlagShininessTex
			If RenderState.UseLightTex Then flags |= Shader.FlagLightmap
			If RenderState.UseCubeTex Then flags |= Shader.FlagCubemap
			If RenderState.BlendMode = Renderer.BlendSolid Then flags |= Shader.FlagSolid
			If RenderState.FogEnabled Then flags |= Shader.FlagFog
			If RenderState.ShadowsEnabled Then flags |= Shader.FlagShadows
			If RenderState.Skinned Then flags |= Shader.FlagSkinned
			If RenderState.BaseTexMode = 2 Then flags |= Shader.FlagBaseCube
			Renderer.SetShaderInt(mFlags, flags)
		End
		#End
		
		'Set shadow data
		If mShadowsEnabled <> -1 Then Renderer.SetShaderInt(mShadowsEnabled, RenderState.ShadowsEnabled)
		If mDepthEpsilon <> -1 Then Renderer.SetShaderFloat(mDepthEpsilon, RenderState.DepthEpsilon)
		
		'Set animation data
		If mSkinned <> -1 Then Renderer.SetShaderInt(mSkinned, RenderState.Skinned)
		If mBones[0] <> -1
			Local lastIndex:Int = Min(Renderer.MaxBones(), RenderState.BoneMatrices.Length())
			For Local i:Int = 0 Until lastIndex
				If mBones[i] <> -1 Then Renderer.SetShaderMat4(mBones[i], RenderState.BoneMatrices[i])
			Next
		End
		
		'Set solid mode
		If mSolidMode <> -1
			If RenderState.BlendMode = Renderer.BlendSolid Then Renderer.SetShaderInt(mSolidMode, True) Else Renderer.SetShaderInt(mSolidMode, False)
		End
		
		'Set color
		If mMaterialColor <> -1 Then Renderer.SetShaderVec4(mMaterialColor, Color.R(RenderState.Color) / 255.0, Color.G(RenderState.Color) / 255.0, Color.B(RenderState.Color) / 255.0, Color.A(RenderState.Color) / 255.0)
		
		'Set ambient
		If mAmbient <> -1 Then Renderer.SetShaderVec3(mAmbient, Color.R(RenderState.Ambient) / 255.0, Color.G(RenderState.Ambient) / 255.0, Color.B(RenderState.Ambient) / 255.0)
	
		'Set specular
		If mSpecular <> -1 Then Renderer.SetShaderVec4(mSpecular, Color.R(RenderState.Specular) / 255.0, Color.G(RenderState.Specular) / 255.0, Color.B(RenderState.Specular) / 255.0, Color.A(RenderState.Specular) / 255.0)
		
		'Set emissive
		If mEmissive <> -1 Then Renderer.SetShaderVec3(mEmissive, Color.R(RenderState.Emissive) / 255.0, Color.G(RenderState.Emissive) / 255.0, Color.B(RenderState.Emissive) / 255.0)
		
		'Set specular power
		If mMaterialSpecularPower <> -1 Then Renderer.SetShaderFloat(mMaterialSpecularPower, RenderState.SpecularPower)
		
		'Set cube opacity
		If mCubeOpacity <> -1 Then Renderer.SetShaderFloat(mCubeOpacity, RenderState.CubeOpacity)
		
		'Set fog
		Renderer.SetShaderVec3(mFogData, RenderState.FogMinDistance, RenderState.FogMaxDistance, Int(RenderState.FogEnabled))
		If RenderState.FogEnabled Then Renderer.SetShaderVec3(mFogColor, Color.R(RenderState.FogColor) / 255.0, Color.G(RenderState.FogColor) / 255.0, Color.B(RenderState.FogColor) / 255.0)
		
		'Set refract coef
		If mRefractCoef <> -1 Then Renderer.SetShaderFloat(mRefractCoef, RenderState.RefractCoef)
		
		'Set lighting
		If mNumLights <> -1 Then Renderer.SetShaderInt(mNumLights, RenderState.NumLights)
		For Local i:Int = 0 Until RenderState.NumLights
			If mLightVector[i] <> -1 Then Renderer.SetShaderVec4(mLightVector[i], RenderState.LightPos[i][0], RenderState.LightPos[i][1], RenderState.LightPos[i][2], RenderState.LightPos[i][3])
			If mLightData[i] <> -1 Then Renderer.SetShaderVec4(mLightData[i], Color.R(RenderState.LightColor[i]) / 255.0, Color.G(RenderState.LightColor[i]) / 255.0, Color.B(RenderState.LightColor[i]) / 255.0, RenderState.LightRadius[i])
		Next
		
		'Set textures
		If mBaseTexSampler <> -1 Then Renderer.SetShaderInt(mBaseTexSampler, Renderer.BaseTexUnit)
		If mAmbientTexSampler <> -1 Then Renderer.SetShaderInt(mAmbientTexSampler, Renderer.AmbientTexUnit)
		If mSpecularTexSampler <> -1 Then Renderer.SetShaderInt(mSpecularTexSampler, Renderer.SpecularTexUnit)
		If mEmissiveTexSampler <> -1 Then Renderer.SetShaderInt(mEmissiveTexSampler, Renderer.EmissiveTexUnit)
		If mNormalTexSampler <> -1 Then Renderer.SetShaderInt(mNormalTexSampler, Renderer.NormalTexUnit)
		If mCubemapSampler <> -1 Then Renderer.SetShaderInt(mCubemapSampler, Renderer.CubemapUnit)
		If mDepthSampler <> -1 Then Renderer.SetShaderInt(mDepthSampler, Renderer.DepthTexUnit)
		If mUseColorTex <> -1 Then Renderer.SetShaderInt(mUseColorTex, RenderState.UseColorTex)
		If mUseAmbientTex <> -1 Then Renderer.SetShaderInt(mUseAmbientTex, RenderState.UseAmbientTex)
		If mUseSpecularTex <> -1 Then Renderer.SetShaderInt(mUseSpecularTex, RenderState.UseSpecularTex)
		If mUseEmissiveTex <> -1 Then Renderer.SetShaderInt(mUseEmissiveTex, RenderState.UseEmissiveTex)
		If mUseNormalTex <> -1 Then Renderer.SetShaderInt(mUseNormalTex, RenderState.UseNormalTex)
		If mUseCubemap <> -1 Then Renderer.SetShaderInt(mUseCubemap, RenderState.UseCubeTex)
	
		'Set texture matrix
		If mTextureMatrix <> -1 Then Renderer.SetShaderMat4(mTextureMatrix, RenderState.TextureMatrix)
	End
Private
	Global mTempMatrix	: Float[16]
End

Class ShaderAttribs Final
Public
	Field mVertexPos		: Int
	Field mVertexNormal			: Int
	Field mVertexTangent		: Int
	Field mVertexColor			: Int
	Field mVertexTexCoords		: Int
	Field mVertexBoneIndices	: Int
	Field mVertexBoneWeights	: Int
	
	Method New(shader:Int)
		mVertexPos = Renderer.ShaderAttribLocation(shader, "VertexPos")
		mVertexNormal = Renderer.ShaderAttribLocation(shader, "VertexNormal")
		mVertexTangent = Renderer.ShaderAttribLocation(shader, "VertexTangent")
		mVertexColor = Renderer.ShaderAttribLocation(shader, "VertexColor")
		mVertexTexCoords = Renderer.ShaderAttribLocation(shader, "VertexTexCoords")
		mVertexBoneIndices = Renderer.ShaderAttribLocation(shader, "VertexBoneIndices")
		mVertexBoneWeights = Renderer.ShaderAttribLocation(shader, "VertexBoneWeights")
	End
	
	Method Enable:Void(coordsOffset:Int, normalsOffset:Int, tangentsOffset:Int, colorsOffset:Int, texCoordsOffset:Int,  boneIndicesOffset:Int, boneWeightsOffset:Int, stride:Int)
		If coordsOffset >= 0 Then Renderer.ShaderEnableAttrib(mVertexPos, 3, stride, coordsOffset)
		If normalsOffset >= 0 Then Renderer.ShaderEnableAttrib(mVertexNormal, 3, stride, normalsOffset)
		If tangentsOffset >= 0 Then Renderer.ShaderEnableAttrib(mVertexTangent, 3, stride, tangentsOffset)
		If colorsOffset >= 0 Then Renderer.ShaderEnableAttrib(mVertexColor, 4, stride, colorsOffset)
		If texCoordsOffset >= 0 Then Renderer.ShaderEnableAttrib(mVertexTexCoords, 4, stride, texCoordsOffset)
		If boneIndicesOffset >= 0 Then Renderer.ShaderEnableAttrib(mVertexBoneIndices, 4, stride, boneIndicesOffset)
		If boneWeightsOffset >= 0 Then Renderer.ShaderEnableAttrib(mVertexBoneWeights, 4, stride, boneWeightsOffset)
	End
	
	Method Disable:Void()
		Renderer.ShaderDisableAttrib(mVertexPos)
		Renderer.ShaderDisableAttrib(mVertexNormal)
		Renderer.ShaderDisableAttrib(mVertexTangent)
		Renderer.ShaderDisableAttrib(mVertexColor)
		Renderer.ShaderDisableAttrib(mVertexTexCoords)
		Renderer.ShaderDisableAttrib(mVertexBoneIndices)
		Renderer.ShaderDisableAttrib(mVertexBoneWeights)
	End
End

Public

Interface ShaderDelegate
	Method SetShaderVars:Void(shader:Shader)
End

Class Shader Final
Public
	Const TypeMinimal					: Int = 0
	Const TypeMinimalShadows	: Int = 1
	Const TypeVertexLighting	: Int = 2
	Const TypePixelLighting		: Int = 3

	Method New(vertex:String, fragment:String, delegate:ShaderDelegate = Null)
'#If TARGET="html5"
		Local version : String = ""
'#Else
		'Local version:String = "#version 120~n"
'#EndIf

		Local precision:String = "" +
		"#ifdef GL_ES~n" +
		'"precision highp int;~n" +
		"precision mediump int;~n" +
		"precision mediump float;~n" +
		"#endif~n"
		
		Local defines:String = "" +
			"#define MAX_LIGHTS " + Renderer.MaxLights() + "~n" +
			"#define MAX_BONES " + Renderer.MaxBones() + "~n"

		Local flags:String = "" '+
		#Rem
			"#define FlagBaseTex " + FlagBaseTex + "~n" +
			"#define FlagNormalTex " + FlagNormalTex + "~n" +
			"#define FlagShininessTex " + FlagShininessTex + "~n" +
			"#define FlagLightmap " + FlagLightmap + "~n" +
			"#define FlagCubemap " + FlagCubemap + "~n" +
			"#define FlagSolid " + FlagSolid + "~n" +
			"#define FlagPixelLighting " + FlagPixelLighting + "~n" +
			"#define FlagFog " + FlagFog + "~n" +
			"#define FlagShadows " + FlagShadows + "~n" +
			"#define FlagSkinned " + FlagSkinned + "~n" +
			"#define FlagBaseCube " + FlagBaseCube + "~n"
		#End
		
		vertex = version + precision + defines + flags + vertex
		fragment = version + precision + defines + flags + fragment
		
		mHandle = Renderer.CreateShader(vertex, fragment)
		mError = Renderer.ShaderError()
		If mHandle <> 0
			mDelegate = delegate
			mUniforms = New ShaderUniforms(mHandle)
			mAttribs = New ShaderAttribs(mHandle)
		End
	End
	
	Method Discard:Void()
		If mHandle <> 0 Then Renderer.FreeShader(mHandle)
		mHandle = 0
		mDelegate = Null
	End
	
	Method Error:String() Property
		Return mError
	End
	
	Method Location:Int(name:String)
		Return Renderer.ShaderLocation(mHandle, name)
	End
	
	Method UniformInt:Void(location:Int, val:Int)
		Renderer.SetShaderInt(location, val)
	End
	
	Method UniformFloat:Void(location:Int, val:Float)
		Renderer.SetShaderFloat(location, val)
	End
	
	Method UniformVec2:Void(location:Int, x:Float, y:Float)
		Renderer.SetShaderVec2(location, x, y)
	End
	
	Method UniformVec3:Void(location:Int, x:Float, y:Float, z:Float)
		Renderer.SetShaderVec3(location, x, y, z)
	End
	
	Method UniformVec4:Void(location:Int, x:Float, y:Float, z:Float, w:Float)
		Renderer.SetShaderVec4(location, x, y, z, w)
	End
	
	Method UniformMat4:Void(location:Int, mat:Float[])
		Renderer.SetShaderMat4(location, mat)
	End
	
	Method Discard:Void()
		If mHandle <> 0 Then Renderer.FreeShader(mHandle)
		mHandle = 0
	End
	
	Method Handle:Int() Property
		Return mHandle
	End
	
	Function DefaultType:Void(type:Int)
		type = Clamp(type, TypeMinimal, TypePixelLighting)
		If type = TypePixelLighting And _PixelLighting().Handle = 0 Then type -= 1
		If type = TypeVertexLighting And _VertexLighting().Handle = 0 Then type -= -1
		If type = TypeMinimalShadows And _MinimalShadows().Handle = 0 Then type -= -1
		mDefaultType = type
	End
	
	Function DefaultType:Int()
		If mDefaultType = -1 Then DefaultType(TypePixelLighting)
		Return mDefaultType
	End
	
	Method _Prepare:Void()
		'mBound = Self
		Renderer.UseShader(mHandle)
		mUniforms.Prepare()
		If mDelegate <> Null Then mDelegate.SetShaderVars(Self)
	End
	
	Method _EnableVertexVars:Void(coordsOffset:Int, normalsOffset:Int, tangentsOffset:Int, colorsOffset:Int, texCoordsOffset:Int, boneIndicesOffset:Int, boneWeightsOffset:Int, stride:Int)
		mAttribs.Enable(coordsOffset, normalsOffset, tangentsOffset, colorsOffset, texCoordsOffset, boneIndicesOffset, boneWeightsOffset, stride)
	End
	
	Method _DisableVertexVars:Void()
		mAttribs.Disable()
	End
	
	Function _Default2D:Shader()
		If mDefault2D = Null Then mDefault2D = New Shader(_2DVertexShader, _2DFragmentShader)
		Return mDefault2D
	End
	
	Function _Default3D:Shader()
		Select DefaultType()
		Case TypePixelLighting
			Return _PixelLighting()
		Case TypeVertexLighting
			Return _VertexLighting()
		Case TypeMinimalShadows
			Return _MinimalShadows()
		Default
			Return _Minimal()
		End
	End
	
	Function _Shadow:Shader()
		If mShadow = Null Then mShadow = New Shader(ShadowVertexShader, ShadowFragmentShader)
		Return mShadow
	End
	
	Function _Skybox:Shader()
		If mSkybox = Null Then mSkybox = New Shader(SkyboxVertexShader, SkyboxFragmentShader)
		Return mSkybox
	End
	
	Function _Minimal:Shader()
		If mMinimal = Null Then mMinimal = New Shader(MinVertexShader, MinFragmentShader)
		Return mMinimal
	End
	
	Function _MinimalShadows:Shader()
		If mMinimalShadows = Null Then mMinimalShadows = New Shader(MinShadowsVertexShader, MinShadowsFragmentShader)
		Return mMinimalShadows
	End
	
	Function _VertexLighting:Shader()
		If mVertexLighting = Null Then mVertexLighting = New Shader(VLitVertexShader, VLitFragmentShader)
		Return mVertexLighting
	End
	
	Function _PixelLighting:Shader()
		If mPixelLighting = Null Then mPixelLighting = New Shader(PLitVertexShader, PLitFragmentShader)
		Return mPixelLighting
	End
	
	Function _CurrentDefault:Void(shader:Shader)
		mCurrentDefault = shader
		shader._Prepare()
	End
	
	Function _CurrentDefault:Shader()
		Return mCurrentDefault
	End
	
	'Function _Bound:Shader()
	'	Return mBound
	'End
Private
	Const FlagBaseTex			: Int = 1
	Const FlagNormalTex		: Int = 2
	Const FlagShininessTex		: Int = 4
	Const FlagLightmap			: Int = 8
	Const FlagCubemap			: Int = 16
	Const FlagSolid			: Int = 32
	Const FlagFog				: Int = 64
	Const FlagShadows			: Int = 128
	Const FlagSkinned			: Int = 256
	Const FlagBaseCube			: Int = 512

	Field mHandle		: Int
	Field mDelegate		: ShaderDelegate
	Field mUniforms		: ShaderUniforms
	Field mAttribs		: ShaderAttribs
	Field mError		: String
	
	Global mDefault2D			: Shader
	Global mShadow	: Shader
	Global mSkybox	: Shader
	Global mMinimal				: Shader
	Global mMinimalShadows	: Shader
	Global mVertexLighting	: Shader
	Global mPixelLighting		: Shader
	Global mDefaultType		: Int = -1
	Global mCurrentDefault		: Shader
	'Global mBound					: Shader
	
	Method New()
	End
End
